# osago-aggregator

Сервис `osago-aggregator` отправляет заявки на расчет ОСАГО в страховые компании и потом опрашивает их для получения 
результатов. Время ожидания пользователем ответа - 60 секунд, каждая страховая может выдавать ответ за любое время, как 
больше, так и меньше.  
Целесообразно выдавать пользователю расчетные данные, как только они становятся доступны сервису, то есть как только получили ответ.
Если в течение 60 секунд не пришел ответ ни от одной страховой - выдавать заглушку. 

Для обеспечения более корректной обработки запроса `osago-aggregator` к внешним сервисам будем использовать в совокупности паттерны 
Timeout, Retry и Circuit Breaker. 

Для оповещения пользователей о результатах расчета будет использовать WebSocket. Для этого дополнительно создадим сервис 
`user-notifiction`, к которому клиентский браузер будет подключаться по WebSocket, будет подписан на события об готовности 
расчета ОСАГО. Как только `osago-aggregator` получит ответ от страховой по расчету - он опубликует событие в ActiveMQ с 
соответствующим идентификатором пользователя, для кого этот расчет предназначается.

Поток обработки запроса на расчет ОСАГО будет выглядеть следующим образом:  
- `core-app` отправляет REST запрос в `osago-aggregaitor` на расчет ОСАГО для конкретного пользователя с заданными параметрами.
- `osago-aggregator` сохраняет данных запрос в собственной БД и отвечает HTTP OK.
- `osago-aggregator` формируем необходимое количество событий на просчет и кидает их в специальную очередь. 
Целесообразно для этого пункта и предыдущего использовать паттерн Transactional Outbox, чтобы не отправить сообщения, если не удалось сохранить запрос. 
- consumer в `osago-aggregator` вычитывает сообщение из очереди, обрабатывает и запускает процесс обращения к страховой за расчетом.
- после получения ответа от страховой, идентифицирует по какому объекту был расчет сопоставляя с данными в БД
- далее результат расчета, сопоставленный и обогащенный нужной информацией (как минимум пользователь который запросил) публикуется в ActiveMQ
- `user-notification` сервис подписанный на такие события, получает, находит пользовательскую WebSocket сессию и отправляет подготовленный расчет пользователю.

Есть несколько нюансов, о которых стоит упомянуть:  

1. Используем очередь (а не pub/sub), куда будут писаться сообщения на запуск расчета ОСАГО, мы гарантируем что одно сообщение
будет вычитано только одним потребителем (хоть они все и подключены к этой очереди), в не зависимости от количества экземпляров сервиса `osago-aggregator`. 
Но в данном случае необходимо мониторить как быстро очередь "разгребается", чтобы сообщения не копились и потребители быстро вычитывали события и запускали логику на расчет.
Альтернативой можно предложить формировать задачи на расчет, сохранять их в БД, по расписанию вычитывать и запускать. 
Но в данном случае необходимо будет предусмотреть более сложную логику синхронизации задач между несколькими экземплярами сервиса, 
чтобы не запускать один и тот же расчет несколько раз. Поэтому вариант с очередью выглядит предпочтительнее.

2. Так же используя очередь, мы можем организовать необходимую компенсационную логику на случай если сообщение было обработано неудачно
или сервис перезапустился - брокер получит nack и вернет сообщение в очередь. Это позволит либо обработать его на другом экземпляре, либо отправить в DQL

3. Почему ActiveMQ, а не Kafka. Помимо механизма pub/sub, используются классические очереди. Нагрузка на message broker
в текущей виде выглядит такой, с которой вполне может справиться ActiveMQ. Реализация и поддержка ActiveMQ проще чем Kafka.